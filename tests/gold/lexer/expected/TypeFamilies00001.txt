HaskellTokenType.module ('module')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('TypeFamilies00001')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- Mostly copy-pasta from https://stackoverflow.com/questions/20870432/type-family-vs-data-family-in-brief\n')
WHITE_SPACE ('\n')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMapKey')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n  ')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.Varsym ('*')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.Varsym ('*')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('empty')
WHITE_SPACE ('       ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('lookup')
WHITE_SPACE ('      ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Maybe')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('insert')
WHITE_SPACE ('      ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n\n')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Collects')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n  ')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('empty')
WHITE_SPACE ('  ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('insert')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('member')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bool')
WHITE_SPACE ('\n  ')
HaskellTokenType.varidRegexp ('toList')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.[ ('[')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
HaskellTokenType.] (']')
WHITE_SPACE ('\n\n')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Foo')
WHITE_SPACE ('\n')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bar')
WHITE_SPACE ('\n\n')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('C')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n   ')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Foo')
WHITE_SPACE ('\n   ')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bar')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- Declare a family of type synonyms, called `Element`\n')
HaskellTokenType.comment ('-- `Element` has kind `* -> *`; it takes one parameter, which we call `container`\n')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('container')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- ByteString is a container for Word8, so...\n')
HaskellTokenType.comment ('-- The Element of a `S.ByteString` is a `Word8`\n')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('S.ByteString')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Word8')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- and the Element of a `L.ByteString` is also `Word8`\n')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('L.ByteString')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Word8')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- Declare a list-like data family\n')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('a')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- Declare a list-like instance for Char\n')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XCons')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
WHITE_SPACE (' ')
HaskellTokenType.( ('(')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
HaskellTokenType.) (')')
WHITE_SPACE (' ')
HaskellTokenType.| ('|')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XNil')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- Declare a number-like instance for ()\n')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.( ('(')
HaskellTokenType.) (')')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XListUnit')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Int')
WHITE_SPACE ('\n\n')
HaskellTokenType.comment ('-- ERROR: "Multiple declarations of `XListUnit'"\n')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.( ('(')
HaskellTokenType.) (')')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XListUnit')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bool')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- (Note: GHCI accepts this; the new declaration just replaces the previous one.)')