plugins {
    id "org.jetbrains.intellij" version "1.7.0"
    id "org.jetbrains.changelog" version "1.3.1"
}

String properties(String key) {
    return project.findProperty(key).toString()
}

version = properties('pluginVersion')

task validateDic(type: Exec) {
    commandLine './tools/validate-dic'
}

task runJFlex(type: Exec) {
    commandLine './tools/run-jflex'
}

task cleanJFlex(type: Exec) {
    commandLine './tools/run-jflex', 'clean'
}

ext {
    javaVersion = properties('javaVersion')
    scalaVersion = properties('scalaVersion')
    scalaBinaryVersion = scalaVersion.split('\\.').take(2).join('.')
}

allprojects {

    apply plugin: 'java'
    apply plugin: 'scala'
    apply plugin: 'org.jetbrains.intellij'

    intellij {
        pluginName = properties('pluginName')
        version = properties('platformVersion')
        type = properties('platformType')
        plugins = ['java', 'yaml']
        // Useful plugins to default-install when developing.
        if (System.properties['DEV_MODE'] == "true") {
            plugins += ['gradle', 'IdeaVIM:0.58']
        }
    }

    repositories {
        mavenCentral()
    }

    configurations {
        provided
        compile.extendsFrom provided
        paradise
    }
    configurations.paradise.transitive = false

    dependencies {

        // Scala support
        compileOnly "org.scala-lang:scala-compiler:${scalaVersion}"
        compile "org.scala-lang:scala-reflect:${scalaVersion}"
        compile "org.scala-lang:scala-library:${scalaVersion}"

        paradise "org.scalamacros:paradise_${scalaVersion}:2.1.1"
        compile "io.estatico:newtype_${scalaBinaryVersion}:0.4.4"
        compile "org.scalaz:scalaz-core_${scalaBinaryVersion}:7.2.17"
        compile "org.yaml:snakeyaml:1.16"

        // Compile-time-only deps.
        compileOnly "com.google.code.findbugs:findbugs:3.0.1"
        compileOnly "com.google.guava:guava:21.0"
    }

    // NOTE: We have Scala and Java sources that depend on each other, and the java.srcDirs
    // will try to be compiled first, so instead we're just setting the scala.srcDirs.
    sourceSets {
        main {
            scala.srcDirs 'src', 'gen'
            resources.srcDirs 'resources'
        }
        test {
            scala.srcDirs 'tests'
            resources.srcDirs 'tests'
        }
    }

    it.tasks.withType(ScalaCompile) {
        String paradiseJar = configurations.paradise.singleFile.path
        scalaCompileOptions.setAdditionalParameters([
            '-deprecation',
            '-feature',
            '-language:existentials',
            '-language:experimental.macros',
            '-language:higherKinds',
            '-unchecked',
            '-Xfatal-warnings',
            '-Xlint',
            '-Xlint:-unused,_',
            '-Yno-adapted-args',
            '-Ywarn-dead-code',
            '-Ywarn-numeric-widen',
            '-Ywarn-unused:imports',
            '-Ywarn-unused:locals',
            '-Ywarn-unused:patvars',
            '-Ywarn-unused:patvars',
            '-Ywarn-unused:privates',
            '-Ywarn-value-discard',
            // Use '-Ymacro-annotations' once moved to scala 2.13
            "-Xplugin:${paradiseJar}".toString()
        ])
    }
}

assemble.dependsOn(validateDic, runJFlex)

project(':jps-plugin') {
    dependencies {
        compile project(':jps-shared')
    }
}

dependencies {
    compile project(':macros')
    compile project(':jps-shared')
    compile project(':jps-plugin')
}

// These are libraries, not plugins, so we disable building them as such.
[':macros', ':jps-shared', ':jps-plugin'].each {
    project(it) {
        buildPlugin.enabled = false
        verifyPlugin.enabled = false
    }
}

static def getGitRev() {
    def proc = "git rev-parse --short HEAD".execute()
    proc.waitFor()
    return proc.text.trim()
}

static def isGitDirty() {
    return "git diff-index --quiet HEAD".execute().waitFor() != 0
}

def getPluginVersion() {
    if (version.endsWith('SNAPSHOT')) {
        if (isGitDirty()) {
            return "$version-${getGitRev()}-dirty"
        } else {
            return "$version-${getGitRev()}"
        }
    } else {
        return version
    }
}

clean.dependsOn cleanJFlex

compileJava.dependsOn runJFlex

// Fixes "unmappable character for encoding ASCII" when compiling files
// containing unicode characters in strings via IntelliJ gradle tasks.
compileJava.options.encoding = "UTF-8"
compileTestJava.options.encoding = "UTF-8"
compileScala.options.encoding = "UTF-8"
compileTestScala.options.encoding = "UTF-8"

patchPluginXml {
    version = getPluginVersion()
}

// Allow re-running tests without forcing a recompile.
test.outputs.upToDateWhen { false }

buildPlugin {
    archiveFileName = "haskforce-${getPluginVersion()}.zip"
}

test {
    if ("1" == System.getenv("OVERWRITE_FIXTURES")) {
        systemProperties.put("idea.tests.overwrite.data", "true")
    }
}

changelog {
    version = properties('pluginVersion')
}
