/*
 * Copyright 2014 Cary M. Robbins
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * To generate sources from this file -
 *   Delete the gen/ directory.
 *   Use Command + Shift + G to generate parser in gen/ directory.
 *   Then generate the lexer using Tools > Generate JFlex Lexer,
 *     then use Command + Shift + G on the lexer.
 *   Be sure to add the gen/ directory to your sources.
 *   In Intellij, right-click the gen directory and choose Mark Directory As > Sources.
 */

{
  parserClass="com.haskforce.parser.HaskellParser"
  parserUtilClass="org.intellij.grammar.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.haskforce.psi"
  psiImplPackage="com.haskforce.psi.impl"

  elementTypeHolderClass="com.haskforce.psi.HaskellTypes"
  elementTypeClass="com.haskforce.psi.HaskellElementType"
  tokenTypeClass="com.haskforce.psi.HaskellTokenType"

  psiImplUtilClass="com.haskforce.psi.impl.HaskellPsiImplUtil"

  tokens=[
    lparen='('
    rparen=')'
    pipe='|'
    comma=','
    semicolon=';'
    lbracket='['
    rbracket=']'
    backtick='`'
    lbrace='{'
    rbrace='}'
    opencom='{-'
    closecom='-}'
    openpragma='{-#'
    closepragma='#-}'
    doublequote='regexp:"'
    thquote="''"
    singlequote="'"
    exlamation='!'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    asterisk='*'
    plus='+'
    period='.'
    slash='/'
    lessthan='<'
    equals='='
    greaterthan='>'
    question='?'
    ampersat='@'
    backslash='\'
    caret='^'
    minus='-'
    tilde='~'
    colon=':'
    doubleperiod='..'
    doublecolon='::'
    leftarrow='<-'
    rightarrow='->'
    doublearrow='=>'
    nullCharacter='\&'
    classtoken='class'
    varidRegexp="regexp:[a-z_][a-zA-Z_0-9']*"
    conid="regexp:[A-Z][a-zA-Z_0-9']*"
    chartoken="regexp:'(\\.|[^'])'"
    integertoken="regexp:(0(o|O)[0-7]+|0(x|X)[0-9a-fA-F]+|[0-9]+)"
    floattoken="regexp:([0-9]+\.[0-9]+((e|E)(\+|\-)?[0-9]+)?|[0-9]+((e|E)(\+|\-)?[0-9]+))"
    comment='regexp:--([^\^\r\n][^\r\n]*|[\r\n])'
    dashes='regexp:--(-)?'
    haddock='regexp:--\^[^\r\n]*'
    // There's a few things that should be weeded out from stringtoken,
    // but when in doubt, be liberal with what you accept.
    stringtoken='regexp:"[^"]*"'
    // Reserved IDs. Should be tokens for IntelliJ reasons. Gives us a nicer
    // PSI tree as side effect.
    DATA='data'
    DEFAULT='default'
    DERIVING='deriving'
    FOREIGN='foreign'
    INSTANCE='instance'
    MODULE='module'
    NEWTYPE='newtype'
    TYPE='type'
    WHERE='where'
    AS='as'
    IMPORT='import'
    INFIX='infix'
    INFIXL='infixl'
    INFIXR='infixr'
    QUALIFIED='qualified'
    HIDING='hiding'
    CASE='case'
    DO='do'
    ELSE='else'
    IF='if'
    IN='in'
    LET='let'
    OF='of'
    THEN='then'
  ]
}

// Haskell 2010 Report - http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

module ::= (whitespace | pragma) module
         | "module" qconid [exports] "where" body
         | body

body ::= impdecl* topdecl*

exports ::= <<commaSeparate2 export>>
export ::= qvar
        | qtycon ["(..)" | cnames]
        | qtycls ["(..)" | qvars]
        | "module" qconid

impdecl ::= "import" ["qualified"] qconid ["as" qconid] [impspec]

private impspec ::= <<commaSeparate2 importt>>
                  | "hiding" <<commaSeparate2 importt>>

// Workaround for https://github.com/JetBrains/Grammar-Kit/issues/32.
importt ::= var
          | tycon ["(..)" | cnames]
          | tycls ["(..)" | vars]

cnames ::= <<commaSeparate cname>>
cname ::= var | con

private topdecl ::= "type" simpletype "=" typee
                  | "data" [context "=>"] simpletype ["=" constrs] [deriving]
                  | "newtype" [context "=>"] simpletype "=" newconstr [deriving]
                  | "class" [scontext "=>"] tycls tyvar ["where" cdecl+]
                  | "instance" [scontext "=>"] qtycls inst ["where" idecl+]
                  | "default" <<commaSeparate typee>>
                  | "foreign" fdecl
                  | decl+      // FIXME: Remove + when implementing decl.

left cdecl ::= gendecl
             | (funlhs | var) rhs

idecl ::= (funlhs | var) rhs

gendecl ::= vars '::' [context '=>'] typee
         | fixity [integertoken] ops
//         | /* Empty */

ops ::= <<sequence op>>
vars ::= <<sequence var>>
fixity ::= "infix" | "infixr" | "infixl"

// Type already taken so we get collisions in generated code. Sigh.
typee ::= btype ['->' typee]

private btype ::= atype btype
                | atype

atype ::= gtycon
        | tyvar
        | <<commaSeparate typee>>
        | '[' typee ']'
        | '(' typee ')'

private gtycon ::= qtycon
                 | "()"
                 | "[]"
                 | '(' "->" ')'
                 | '(' ',' (',')+ ')'

context ::= classs
          | <<commaSeparate classs>>

// "Class" is reserved in Java.
classs ::= qtycls tyvar
        | qtycls '(' tyvar atype+ ')'

scontext ::= simpleclass
           | <<commaSeparate simpleclass>>
private simpleclass ::= qtycls tyvar

private simpletype ::= tycon tyvar*

constrs ::= constr ('|' constr)*

constr ::= con (['!'] atype)*
        | (btype | '!'atype) conop (btype | '!'atype)
        | con '{' ((fielddecl ',')* fielddecl)? '}'

newconstr ::= con atype
            | con '{' var '::' typee '}'

private fielddecl ::= vars '::' (typee | '!' atype)

private deriving ::= "deriving" (dclass|<<commaSeparate dclass>>)
private dclass ::= qtycls

inst ::= gtycon
       | '(' gtycon tyvar* ')'
       | '(' tyvar ',' (tyvar ',')* tyvar ')'        // No commaSep, >= 2 args.
       | '[' tyvar ']'
       | '(' tyvar "->" tyvar ')'

// FIXME: Replace with full implementation.
fdecl ::= decl+ // "import" callconv [safety] impent var '::' ftype
        // | "export" callconv expent var "::" ftype

// FIXME: Replace with full implementation.
funlhs ::= decl+ // var apat+
        // | pat varop pat
        // | '(' funlhs ')' apat+

// FIXME: Replace with full implementation.
rhs ::= decl+ // exp ["where" decls]
//       | gdrhs ["where" decls]

private decl ::= ( whitespace | lexeme )

private lexeme ::= literal | reservedop | reservedid | pragma
                 | qconid | qinfixvarid | qvarid | qinfixconid | qvarsym
                 | qconsym | special
private literal ::= floattoken | integertoken | chartoken | stringtoken
private whitespace ::= whitestuff +
private space ::= LINE_WS
private newline ::= EOL
private whitestuff ::= whitechar | comment | ncomment | haddock
whitechar ::= space | newline | '\t'
pragma ::= openpragma (!closepragma (lexeme | space))+ closepragma
ncomment ::= opencom anyseq? (ncomment anyseq?)* closecom
anyseq ::= !( opencom | closecom ) (lexeme | whitechar)+
special ::= '(' | ')' | ',' | ';' | '[' | ']' | '{' | '}' | thquote | backtick
symbol ::= '!' | '#' | '$' | '%' | '&' | '*' | '+' | '.' | '/' | '<' | '=' | '>' | '?' | '@'
         | '\' | '^' | '|' | '-' | '~' | ':'
private varid ::= !reservedid varidRegexp
private reservedExpr ::= 'case' | 'do' | 'else' | 'if' | 'in' | 'let' | 'of' | 'then'
private reservedDecl ::= 'class' | 'data' | 'default' | 'deriving' | 'foreign' | 'instance'
                       | 'newtype' | 'type' | 'where'
// TODO: Remove 'as' when the rest of the parser is in place.
// Import00002.hs will change expected output when that is done.
private reservedMeta ::= 'as' | 'infix' | 'infixl' | 'infixr'
private reservedVar ::= '_'
private reservedid  ::= reservedExpr | reservedDecl | reservedMeta | reservedVar

varsym ::= !(reservedop | dashes ) ( !':' symbol+ )
consym ::= !reservedop ( ':' symbol* )

reservedop ::= '..' | '::' | '=' | '\' | '|' | '<-' | '->' | '@' | '~' | '=>'

tyvar ::= varid
tycon ::= conid
tycls ::= conid
modulePrefix ::= (conid '.')+

qvarid ::= [modulePrefix] varid
qinfixvarid ::= '`' [modulePrefix] varid '`'
qconid ::= [modulePrefix] conid
qinfixconid ::= '`' [modulePrefix] conid '`'
qtycon ::= [modulePrefix] tycon
qtycls ::= [modulePrefix] tycls
qvarsym ::= [modulePrefix] varsym
qconsym ::= [modulePrefix] consym

var ::= varid | '(' varsym ')'
qvars ::= <<commaSeparate qvar>>
qvar ::= qvarid | '(' qvarsym ')'
con ::= conid | '(' consym ')'
qcon ::= qconid | '(' gconsym ')'
varop ::= varsym | '`' varid '`'
qvarop ::= qvarsym | '`' qvarid '`'
conop ::= consym | '`' conid '`'
qconop ::= gconsym | '`' qconid '`'
op ::= varop | conop
qop ::= qvarop | qconop
gconsym ::= ':' | qconsym

// Meta-Helpers

// Comma-separate a list of the parameter.
private meta commaSeparate ::= '(' <<p>> (',' <<p>>)* ')' {pin(".*")=1}
// Comma-separate a list of the parameter with a trailing comma.
private meta commaSeparate2 ::= '(' <<p>> (',' (<<p>> | &')'))* ')' {pin(".*")=1}

private meta sequence ::= <<p>> (',' <<p>>)*  {pin(".*")=1}