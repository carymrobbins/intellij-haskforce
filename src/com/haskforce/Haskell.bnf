/*
 * Copyright 2014 Cary M. Robbins
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * To generate sources from this file -
 *   Delete the gen/ directory.
 *   Use Command + Shift + G to generate parser in gen/ directory.
 *   Then generate the lexer using Tools > Generate JFlex Lexer,
 *     then use Command + Shift + G on the lexer.
 *   Be sure to add the gen/ directory to your sources.
 *   In Intellij, right-click the gen directory and choose Mark Directory As > Sources.
 */

{
  parserClass="com.haskforce.parser.HaskellParser"
  parserUtilClass="org.intellij.grammar.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.haskforce.psi"
  psiImplPackage="com.haskforce.psi.impl"

  elementTypeHolderClass="com.haskforce.psi.HaskellTypes"
  elementTypeClass="com.haskforce.psi.HaskellElementType"
  tokenTypeClass="com.haskforce.psi.HaskellTokenType"

  psiImplUtilClass="com.haskforce.psi.impl.HaskellPsiImplUtil"

  tokens=[
    lparen='('
    rparen=')'
    pipe='|'
    comma=','
    semicolon=';'
    lbracket='['
    rbracket=']'
    backtick='`'
    lbrace='{'
    rbrace='}'
    opencom='{-'
    closecom='-}'
    space=' '
    doublequote='regexp:"'
    singlequote="'"
    exlamation='!'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    asterisk='*'
    plus='+'
    period='.'
    slash='/'
    lessthan='<'
    equals='='
    greaterthan='>'
    question='?'
    ampersat='@'
    backslash='\'
    caret='^'
    minus='-'
    tilde='~'
    colon=':'
    doubleperiod='..'
    doublecolon='::'
    leftarrow='<-'
    rightarrow='->'
    doublearrow='=>'
    nullCharacter='\&'
    classtoken='class'
    charesc="regexp:\\(a|b|f|n|r|t|v|\\|\||'|&)"
    varidRegexp="regexp:[a-z_][a-zA-Z_0-9']*"
    conid="regexp:[A-Z][a-zA-Z_0-9']*"
    whiteEscapes="regexp:[\r\n\v\t]"
    stringtoken='regexp:"(\\\s+\\|\\"|[^"])*"'
    chartoken="regexp:'(\\.|[^'])'"
    integertoken="regexp:(0(o|O)[0-7]+|0(x|X)[0-9a-fA-F]+|[0-9]+)[^\.]"
    floattoken="regexp:([0-9]+\.[0-9]+((e|E)(\+|\-)?[0-9]+)?|[0-9]+((e|E)(\+|\-)?[0-9]+))"
    comment='regexp:--[^\^\r\n][^\r\n]*'
    haddock='regexp:--\^[^\r\n]*'
    dashes='regexp:--(-)*'
    pragma='regexp:\{\-\#[^\#]+\#\-\}'
  ]
}

// Haskell 2010 Report - http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

program ::= {pragma} * { whitespace | lexeme } *
private lexeme ::= qvarid | qconid | qvarsym | qconsym
                 | literal | special | reservedop | reservedid
private literal ::= integertoken | floattoken | chartoken | stringtoken
special ::= '(' | ')' | ',' | ';' | '[' | ']' | '`' | '{' | '}'
private whitespace ::= whitetoken {whitetoken} *
private whitetoken ::= space | whitechar | comment | ncomment | haddock
whitechar ::= space | whiteEscapes
ncomment ::= opencom anyseq {ncomment anyseq} * closecom
anyseq ::= !( opencom | closecom ) (lexeme | space) *
symbol ::= '!' | '#' | '$' | '%' | '&' | '*' | '+' | '.' | '/' | '<' | '=' | '>' | '?' | '@'
         | '\' | '^' | '|' | '-' | '~' | ':'
varid ::= !(reservedid | dashes) varidRegexp
reservedid  ::= 'case' | 'class' | 'data' | 'default' | 'deriving' | 'do' | 'else'
              | 'foreign' | 'if' | 'import' | 'infix' | 'infixl' | 'infixr'
              | 'instance' | 'in' | 'let' | 'module' | 'newtype' | 'of' | 'then' | 'type'
              | 'where' | '_'

varsym ::= !(reservedop whitetoken) ( !':' symbol {symbol} * )
consym ::= !reservedopWithoutCons ( ':' {symbol} *)

reservedopWithoutCons ::= '..' | '::' | '=' | '\' | '|' | '<-' | '->' | '@' | '~' | '=>'
reservedop ::= ':' | reservedopWithoutCons

modid       ::= {conid '.'} * conid

qvarid	    ::= [modid '.'] varid
qconid	    ::= [modid '.'] conid
qvarsym	    ::= [modid '.'] varsym
qconsym	    ::= [modid '.'] consym
