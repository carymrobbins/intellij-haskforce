/*
 * Copyright 2014 Cary M. Robbins
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * To generate sources from this file -
 *   Delete the gen/ directory.
 *   Use Command + Shift + G to generate parser in gen/ directory.
 *
 *   The lexer belonging to this parser is located in
 *   highlighting/_HaskellSyntaxHighlightingLexer.flex. See that file for
 *   instructions on how to generate it.
 *
 *   Be sure to add the gen/ directory to your sources.
 *   In Intellij, right-click the gen directory and choose Mark Directory As > Sources.
 */

{
  parserClass="com.haskforce.parser.HaskellParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.haskforce.psi"
  psiImplPackage="com.haskforce.psi.impl"

  elementTypeHolderClass="com.haskforce.psi.HaskellTypes"
  elementTypeClass="com.haskforce.psi.HaskellElementType"
  tokenTypeClass="com.haskforce.psi.HaskellTokenType"

  psiImplUtilClass="com.haskforce.psi.impl.HaskellPsiImplUtil"

  implements("varid|conid")="com.intellij.psi.PsiNamedElement"

  tokens=[
    lparen='('
    rparen=')'
    pipe='|'
    comma=','
    semicolon=';'
    lbracket='['
    rbracket=']'
    backtick='`'
    lbrace='{'
    rbrace='}'
    opencom='{-'
    closecom='-}'
    openpragma='{-#'
    closepragma='#-}'
    doublequote='"'
    thquote="''"
    singlequote="'"
    exclamation='!'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    asterisk='*'
    plus='+'
    period='.'
    slash='/'
    lessthan='<'
    equals='='
    greaterthan='>'
    question='?'
    ampersat='@'
    backslash='\'
    caret='^'
    minus='-'
    underscore='_'
    tilde='~'
    colon=':'
    doubleperiod='..'
    doublecolon='::'
    leftarrow='<-'
    rightarrow='->'
    doublearrow='=>'
    nullCharacter='\&'
    classtoken='class'
    varidRegexp="regexp:[a-z_][a-zA-Z_0-9']*"
    conidRegexp="regexp:[A-Z][a-zA-Z_0-9']*"
    chartoken="regexp:'(\\.|[^'])'"
    integertoken="regexp:(0(o|O)[0-7]+|0(x|X)[0-9a-fA-F]+|[0-9]+)"
    floattoken="regexp:([0-9]+\.[0-9]+((e|E)(\+|\-)?[0-9]+)?|[0-9]+((e|E)(\+|\-)?[0-9]+))"
    comment='regexp:--([^\^\r\n][^\r\n]*|[\r\n])'
    commenttext='regexp:[^{}-]+'
    dashes='regexp:--(-)?'
    haddock='regexp:--\^[^\r\n]*'
    stringtoken='regexp:"(\\\s*\n\s*\\|\\"|[^"\n])*"'
    badstringtoken='regexp:"(\\\s*\n\s*|\\"|[^"\n])*'
    // Reserved IDs. Should be tokens for IntelliJ reasons. Gives us a nicer
    // PSI tree as side effect.
    DATA='data'
    DEFAULT='default'
    DERIVING='deriving'
    FOREIGN='foreign'
    INSTANCE='instance'
    MODULE='module'
    NEWTYPE='newtype'
    TYPE='type'
    WHERE='where'
    AS='as'
    IMPORT='import'
    INFIX='infix'
    INFIXL='infixl'
    INFIXR='infixr'
    QUALIFIED='qualified'
    HIDING='hiding'
    CASE='case'
    DO='do'
    ELSE='else'
    CPPELSE='#else'
    CPPENDIF='#endif'
    CPPIF='regexp:#if ([^\r\n]*)'
    IF='if'
    IN='in'
    LET='let'
    OF='of'
    THEN='then'
    EXPORTTOKEN='export'
    CONSYMTOK="Consym"
    FORALLTOKEN='forall'
  ]
}

// Haskell 2010 Report - http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

module ::= (whitespace | ppragma | cpp) module
         | "module" qconid [exports] "where" body
         | body

body ::= impdecl* topdecl*

exports ::= <<commaSeparate2 export>>
export ::= cpp
        | qvar
        | qtycon ["(..)" | cnames]
        | qtycls ["(..)" | qvars]
        | "module" qconid

impdecl ::= cpp
          | "import" ["qualified"] qconid ["as" qconid] [impspec]

private impspec ::= <<commaSeparate2 importt>>
                  | "hiding" <<commaSeparate2 importt>>

// Workaround for https://github.com/JetBrains/Grammar-Kit/issues/32.
importt ::= var
          | tycon ["(..)" | cnames]
          | tycls ["(..)" | vars]

cnames ::= <<commaSeparate cname>>
cname ::= var | con

vars ::= <<sequence var>>

private topdecl ::= ( whitespace | gendecl | lexeme )

private lexeme ::= cpp | literal | reservedop | reservedid | ppragma
                 | qconid | qinfixvarid | qvarid | qinfixconid | qvarsym
                 | qconsym | special | symbol | "'" | "''"

// Type signatures. Useful for go to definition.
gendecl ::= vars '::'

private literal ::= floattoken | integertoken | chartoken | pstringtoken
private whitespace ::= whitestuff +
private space ::= LINE_WS
private newline ::= EOL
private whitestuff ::= whitechar | comment | haddock
whitechar ::= space | newline | '\t'
ppragma ::= openpragma PRAGMA+ closepragma
special ::= '(' | ')' | ',' | ';' | '[' | ']' | '{' | '}' | thquote | backtick
symbol ::= '!' | '#' | '$' | '%' | '&' | '*' | '+' | '.' | '/' | '<' | '=' | '>' | '?' | '@'
         | '\' | '^' | '|' | '-' | '~' | ':'
varid ::= !reservedid varidRegexp {
        methods=[getName getReference setName]
    }
conid ::= conidRegexp {
        methods=[getName getReference setName]
    }

private reservedExpr ::= 'case' | 'do' | 'else' | 'if' | 'in' | 'let' | 'of' | 'then'
private reservedDecl ::= 'class' | 'data' | 'default' | 'deriving' | 'foreign' | 'instance'
                       | 'newtype' | 'type' | 'where' | 'forall'
private reservedMeta ::= 'as' | 'export' | 'foreign' | 'import' | 'infix'
                       | 'infixl' | 'infixr'
private reservedVar ::= '_'
private reservedid  ::= reservedExpr | reservedDecl | reservedMeta | reservedVar

varsym ::= !(reservedop | dashes ) ( !':' symbol+ )
consym ::= CONSYMTOK

reservedop ::= '..' | '::' | '=' | '\' | '|' | '<-' | '->' | '@' | '~' | '=>'

tyvar ::= varid
tycon ::= conid
tycls ::= conid
modulePrefix ::= (conidRegexp '.')+

qvarid ::= [modulePrefix] varid
qinfixvarid ::= '`' [modulePrefix] varid '`'
qconid ::= [modulePrefix] conidRegexp
qinfixconid ::= '`' [modulePrefix] conidRegexp '`'
qtycon ::= [modulePrefix] tycon
qtycls ::= [modulePrefix] tycls
qvarsym ::= [modulePrefix] varsym
qconsym ::= [modulePrefix] consym

private var ::= varid | '(' varsym ')'
qvars ::= <<commaSeparate qvar>>
qvar ::= qvarid | '(' qvarsym ')'
con ::= conidRegexp | '(' consym ')'

pstringtoken ::= '"' STRINGTOKEN* '"'

// Misc cross-cutting stuff.

cpp ::= CPPIF | CPPELSE | CPPENDIF

// Meta-Helpers

// Comma-separate a list of the parameter.
private meta commaSeparate ::= '(' <<p>> (',' <<p>>)* ')' {pin(".*")=1}
// Comma-separate a list of the parameter with a trailing comma.
private meta commaSeparate2 ::= '(' <<p>> (',' (<<p>> | &')'))* ')' {pin(".*")=1}

private meta sequence ::= <<p>> (',' <<p>>)*  {pin(".*")=1}
